/**
 * Property-Based Test: JWT Token Contains Role Information
 * 
 * **Property 7: JWT Token Contains Role Information**
 * **Validates: Requirements 1.2**
 * 
 * For any JWT token generated by the authentication system, it should contain
 * the user's role and permissions in the payload.
 * 
 * This test validates that:
 * - All generated JWT tokens contain user role information
 * - Tokens contain user permissions (if applicable)
 * - Token payload includes all required user identification fields
 * - Decoded tokens can be used to verify user authorization
 * - Role information is preserved through token generation and verification
 */

import * as fc from 'fast-check';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import path from 'path';
import jwtService, { JWTPayload } from '@modules/auth/jwt.service';
import { UserRole } from '@models/User.model';

// Load environment variables
dotenv.config({ path: path.resolve(__dirname, '../../../.env') });

describe('Property 7: JWT Token Contains Role Information', () => {
  /**
   * Helper function to decode JWT token without verification
   * Used to inspect token payload structure
   */
  const decodeTokenPayload = (token: string): any => {
    return jwt.decode(token);
  };

  /**
   * Helper function to verify token contains all required fields
   */
  const hasRequiredFields = (payload: any): boolean => {
    return (
      payload !== null &&
      typeof payload === 'object' &&
      'userId' in payload &&
      'username' in payload &&
      'email' in payload &&
      'role' in payload
    );
  };

  /**
   * Helper function to check if role is valid
   */
  const isValidRole = (role: any): boolean => {
    return Object.values(UserRole).includes(role);
  };

  /**
   * Property: Generated access tokens contain role information
   * For any user data, the generated access token should contain the user's role
   */
  it('should include role information in access token payload', () => {
    fc.assert(
      fc.property(
        fc.record({
          userId: fc.integer({ min: 1, max: 1000000 }),
          username: fc.string({ minLength: 5, maxLength: 40 })
            .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
          email: fc.emailAddress(),
          role: fc.constantFrom(...Object.values(UserRole)),
          permissions: fc.option(
            fc.array(
              fc.constantFrom(
                'read:students',
                'write:students',
                'read:staff',
                'write:staff',
                'read:attendance',
                'write:attendance',
                'read:exams',
                'write:exams',
                'read:finance',
                'write:finance',
                'read:library',
                'write:library'
              ),
              { minLength: 0, maxLength: 5 }
            ),
            { nil: undefined }
          )
        }),
        (userData) => {
          // Generate access token
          const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
            userId: userData.userId,
            username: userData.username,
            email: userData.email,
            role: userData.role,
            permissions: userData.permissions
          };

          const token = jwtService.generateAccessToken(payload);

          // Verify token is a string
          expect(typeof token).toBe('string');
          expect(token.length).toBeGreaterThan(0);

          // Decode token payload
          const decodedPayload = decodeTokenPayload(token);

          // Verify payload contains all required fields
          expect(hasRequiredFields(decodedPayload)).toBe(true);

          // Verify role is present and matches input
          expect(decodedPayload.role).toBeDefined();
          expect(decodedPayload.role).toBe(userData.role);

          // Verify role is a valid UserRole
          expect(isValidRole(decodedPayload.role)).toBe(true);

          // Verify userId matches
          expect(decodedPayload.userId).toBe(userData.userId);

          // Verify username matches
          expect(decodedPayload.username).toBe(userData.username);

          // Verify email matches
          expect(decodedPayload.email).toBe(userData.email);

          // Verify permissions if provided
          if (userData.permissions !== undefined) {
            expect(decodedPayload.permissions).toBeDefined();
            expect(Array.isArray(decodedPayload.permissions)).toBe(true);
            expect(decodedPayload.permissions).toEqual(userData.permissions);
          }

          // Verify token has standard JWT fields
          expect(decodedPayload.iat).toBeDefined(); // Issued at
          expect(decodedPayload.exp).toBeDefined(); // Expiration
          expect(typeof decodedPayload.iat).toBe('number');
          expect(typeof decodedPayload.exp).toBe('number');

          // Verify expiration is in the future
          const now = Math.floor(Date.now() / 1000);
          expect(decodedPayload.exp).toBeGreaterThan(now);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Generated refresh tokens contain role information
   * For any user data, the generated refresh token should contain the user's role
   */
  it('should include role information in refresh token payload', () => {
    fc.assert(
      fc.property(
        fc.record({
          userId: fc.integer({ min: 1, max: 1000000 }),
          username: fc.string({ minLength: 5, maxLength: 40 })
            .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
          email: fc.emailAddress(),
          role: fc.constantFrom(...Object.values(UserRole)),
          permissions: fc.option(
            fc.array(
              fc.constantFrom(
                'read:students',
                'write:students',
                'read:attendance',
                'write:attendance'
              ),
              { minLength: 0, maxLength: 3 }
            ),
            { nil: undefined }
          ),
          rememberMe: fc.boolean()
        }),
        (userData) => {
          // Generate refresh token
          const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
            userId: userData.userId,
            username: userData.username,
            email: userData.email,
            role: userData.role,
            permissions: userData.permissions
          };

          const token = jwtService.generateRefreshToken(payload, userData.rememberMe);

          // Verify token is a string
          expect(typeof token).toBe('string');
          expect(token.length).toBeGreaterThan(0);

          // Decode token payload
          const decodedPayload = decodeTokenPayload(token);

          // Verify payload contains all required fields
          expect(hasRequiredFields(decodedPayload)).toBe(true);

          // Verify role is present and matches input
          expect(decodedPayload.role).toBeDefined();
          expect(decodedPayload.role).toBe(userData.role);

          // Verify role is a valid UserRole
          expect(isValidRole(decodedPayload.role)).toBe(true);

          // Verify all user fields match
          expect(decodedPayload.userId).toBe(userData.userId);
          expect(decodedPayload.username).toBe(userData.username);
          expect(decodedPayload.email).toBe(userData.email);

          // Verify permissions if provided
          if (userData.permissions !== undefined) {
            expect(decodedPayload.permissions).toBeDefined();
            expect(decodedPayload.permissions).toEqual(userData.permissions);
          }

          // Verify token has standard JWT fields
          expect(decodedPayload.iat).toBeDefined();
          expect(decodedPayload.exp).toBeDefined();
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Verified tokens preserve role information
   * For any generated token, verifying it should return the same role information
   */
  it('should preserve role information through verification', () => {
    fc.assert(
      fc.property(
        fc.record({
          userId: fc.integer({ min: 1, max: 1000000 }),
          username: fc.string({ minLength: 5, maxLength: 40 })
            .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
          email: fc.emailAddress(),
          role: fc.constantFrom(...Object.values(UserRole)),
          permissions: fc.option(
            fc.array(
              fc.constantFrom(
                'read:students',
                'write:students',
                'read:staff',
                'write:staff',
                'read:exams',
                'write:exams'
              ),
              { minLength: 1, maxLength: 4 }
            ),
            { nil: undefined }
          )
        }),
        (userData) => {
          // Generate access token
          const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
            userId: userData.userId,
            username: userData.username,
            email: userData.email,
            role: userData.role,
            permissions: userData.permissions
          };

          const token = jwtService.generateAccessToken(payload);

          // Verify token
          const verifiedPayload = jwtService.verifyAccessToken(token);

          // Verify role is preserved
          expect(verifiedPayload.role).toBe(userData.role);

          // Verify all fields are preserved
          expect(verifiedPayload.userId).toBe(userData.userId);
          expect(verifiedPayload.username).toBe(userData.username);
          expect(verifiedPayload.email).toBe(userData.email);

          // Verify permissions are preserved if provided
          if (userData.permissions !== undefined) {
            expect(verifiedPayload.permissions).toBeDefined();
            expect(verifiedPayload.permissions).toEqual(userData.permissions);
          }

          // Verify role is still valid after verification
          expect(isValidRole(verifiedPayload.role)).toBe(true);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: All user roles are supported in tokens
   * For each defined user role, tokens should be generated and verified correctly
   */
  it('should support all defined user roles in tokens', () => {
    fc.assert(
      fc.property(
        fc.record({
          userId: fc.integer({ min: 1, max: 1000000 }),
          username: fc.string({ minLength: 5, maxLength: 40 })
            .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
          email: fc.emailAddress(),
          role: fc.constantFrom(...Object.values(UserRole))
        }),
        (userData) => {
          // Generate token for each role
          const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
            userId: userData.userId,
            username: userData.username,
            email: userData.email,
            role: userData.role
          };

          const token = jwtService.generateAccessToken(payload);
          const decodedPayload = decodeTokenPayload(token);

          // Verify role is present and valid
          expect(decodedPayload.role).toBe(userData.role);
          expect(isValidRole(decodedPayload.role)).toBe(true);

          // Verify token can be verified
          const verifiedPayload = jwtService.verifyAccessToken(token);
          expect(verifiedPayload.role).toBe(userData.role);

          // Verify role matches one of the defined roles
          expect(Object.values(UserRole)).toContain(userData.role);
        }
      ),
      { numRuns: 50 }
    );
  });

  /**
   * Property: Token payload structure is consistent
   * For any generated token, the payload structure should be consistent
   */
  it('should maintain consistent payload structure across all tokens', () => {
    fc.assert(
      fc.property(
        fc.array(
          fc.record({
            userId: fc.integer({ min: 1, max: 1000000 }),
            username: fc.string({ minLength: 5, maxLength: 40 })
              .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
            email: fc.emailAddress(),
            role: fc.constantFrom(...Object.values(UserRole)),
            permissions: fc.option(
              fc.array(
                fc.constantFrom('read:students', 'write:students', 'read:exams'),
                { minLength: 0, maxLength: 3 }
              ),
              { nil: undefined }
            )
          }),
          { minLength: 2, maxLength: 5 }
        ),
        (usersData) => {
          const tokens = usersData.map(userData => {
            const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
              userId: userData.userId,
              username: userData.username,
              email: userData.email,
              role: userData.role,
              permissions: userData.permissions
            };

            return {
              token: jwtService.generateAccessToken(payload),
              originalData: userData
            };
          });

          // Verify all tokens have consistent structure
          tokens.forEach(({ token, originalData }) => {
            const decodedPayload = decodeTokenPayload(token);

            // All tokens should have the same required fields
            expect(hasRequiredFields(decodedPayload)).toBe(true);

            // All tokens should have role field
            expect(decodedPayload.role).toBeDefined();
            expect(decodedPayload.role).toBe(originalData.role);

            // All tokens should have standard JWT fields
            expect(decodedPayload.iat).toBeDefined();
            expect(decodedPayload.exp).toBeDefined();

            // All tokens should have valid roles
            expect(isValidRole(decodedPayload.role)).toBe(true);
          });
        }
      ),
      { numRuns: 20 }
    );
  });

  /**
   * Property: Permissions array is preserved correctly
   * For any token with permissions, the permissions array should be preserved exactly
   */
  it('should preserve permissions array structure and content', () => {
    fc.assert(
      fc.property(
        fc.record({
          userId: fc.integer({ min: 1, max: 1000000 }),
          username: fc.string({ minLength: 5, maxLength: 40 })
            .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
          email: fc.emailAddress(),
          role: fc.constantFrom(...Object.values(UserRole)),
          permissions: fc.array(
            fc.constantFrom(
              'read:students',
              'write:students',
              'read:staff',
              'write:staff',
              'read:attendance',
              'write:attendance',
              'read:exams',
              'write:exams',
              'read:finance',
              'write:finance',
              'read:library',
              'write:library',
              'read:reports',
              'write:reports'
            ),
            { minLength: 1, maxLength: 8 }
          )
        }),
        (userData) => {
          // Generate token with permissions
          const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
            userId: userData.userId,
            username: userData.username,
            email: userData.email,
            role: userData.role,
            permissions: userData.permissions
          };

          const token = jwtService.generateAccessToken(payload);
          const decodedPayload = decodeTokenPayload(token);

          // Verify permissions array is present
          expect(decodedPayload.permissions).toBeDefined();
          expect(Array.isArray(decodedPayload.permissions)).toBe(true);

          // Verify permissions array length matches
          expect(decodedPayload.permissions.length).toBe(userData.permissions.length);

          // Verify permissions array content matches exactly
          expect(decodedPayload.permissions).toEqual(userData.permissions);

          // Verify each permission is preserved
          userData.permissions.forEach(permission => {
            expect(decodedPayload.permissions).toContain(permission);
          });

          // Verify through verification as well
          const verifiedPayload = jwtService.verifyAccessToken(token);
          expect(verifiedPayload.permissions).toEqual(userData.permissions);
        }
      ),
      { numRuns: 50 }
    );
  });

  /**
   * Property: Role information enables authorization decisions
   * For any token, the role information should be sufficient for authorization
   */
  it('should provide sufficient role information for authorization', () => {
    fc.assert(
      fc.property(
        fc.record({
          userId: fc.integer({ min: 1, max: 1000000 }),
          username: fc.string({ minLength: 5, maxLength: 40 })
            .filter(s => /^[a-zA-Z0-9_]+$/.test(s)),
          email: fc.emailAddress(),
          role: fc.constantFrom(...Object.values(UserRole))
        }),
        (userData) => {
          // Generate token
          const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
            userId: userData.userId,
            username: userData.username,
            email: userData.email,
            role: userData.role
          };

          const token = jwtService.generateAccessToken(payload);
          const verifiedPayload = jwtService.verifyAccessToken(token);

          // Verify we can make authorization decisions based on role
          const isAdmin = verifiedPayload.role === UserRole.SCHOOL_ADMIN;
          const isTeacher = 
            verifiedPayload.role === UserRole.SUBJECT_TEACHER ||
            verifiedPayload.role === UserRole.CLASS_TEACHER ||
            verifiedPayload.role === UserRole.DEPARTMENT_HEAD;
          const isStudent = verifiedPayload.role === UserRole.STUDENT;
          const isParent = verifiedPayload.role === UserRole.PARENT;
          const isCoordinator =
            verifiedPayload.role === UserRole.ECA_COORDINATOR ||
            verifiedPayload.role === UserRole.SPORTS_COORDINATOR;
          const isStaff = 
            verifiedPayload.role === UserRole.LIBRARIAN ||
            verifiedPayload.role === UserRole.ACCOUNTANT ||
            verifiedPayload.role === UserRole.NON_TEACHING_STAFF ||
            verifiedPayload.role === UserRole.TRANSPORT_MANAGER ||
            verifiedPayload.role === UserRole.HOSTEL_WARDEN;

          // Verify role categorization is possible
          const hasRoleCategory = isAdmin || isTeacher || isStudent || isParent || isCoordinator || isStaff;
          expect(hasRoleCategory).toBe(true);

          // Verify role is one of the defined roles
          expect(Object.values(UserRole)).toContain(verifiedPayload.role);

          // Verify we have user identification for audit trails
          expect(verifiedPayload.userId).toBeDefined();
          expect(typeof verifiedPayload.userId).toBe('number');
          expect(verifiedPayload.userId).toBeGreaterThan(0);
        }
      ),
      { numRuns: 100 }
    );
  });
});
